
LD_TEC_PS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000afe  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000b72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000026  00800060  00800060  00000b72  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b72  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000ba4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  00000be0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000a35  00000000  00000000  00000cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000044c  00000000  00000000  000016fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000060b  00000000  00000000  00001b49  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003c4  00000000  00000000  00002154  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003f8  00000000  00000000  00002518  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007f9  00000000  00000000  00002910  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00003109  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	17 c0       	rjmp	.+46     	; 0x30 <__ctors_end>
   2:	26 c0       	rjmp	.+76     	; 0x50 <__bad_interrupt>
   4:	25 c0       	rjmp	.+74     	; 0x50 <__bad_interrupt>
   6:	24 c0       	rjmp	.+72     	; 0x50 <__bad_interrupt>
   8:	23 c0       	rjmp	.+70     	; 0x50 <__bad_interrupt>
   a:	22 c0       	rjmp	.+68     	; 0x50 <__bad_interrupt>
   c:	c4 c3       	rjmp	.+1928   	; 0x796 <__vector_6>
   e:	20 c0       	rjmp	.+64     	; 0x50 <__bad_interrupt>
  10:	1f c0       	rjmp	.+62     	; 0x50 <__bad_interrupt>
  12:	0a c5       	rjmp	.+2580   	; 0xa28 <__vector_9>
  14:	1d c0       	rjmp	.+58     	; 0x50 <__bad_interrupt>
  16:	1c c0       	rjmp	.+56     	; 0x50 <__bad_interrupt>
  18:	3d c4       	rjmp	.+2170   	; 0x894 <__vector_12>
  1a:	1a c0       	rjmp	.+52     	; 0x50 <__bad_interrupt>
  1c:	de c3       	rjmp	.+1980   	; 0x7da <__vector_14>
  1e:	18 c0       	rjmp	.+48     	; 0x50 <__bad_interrupt>
  20:	17 c0       	rjmp	.+46     	; 0x50 <__bad_interrupt>
  22:	16 c0       	rjmp	.+44     	; 0x50 <__bad_interrupt>
  24:	15 c0       	rjmp	.+42     	; 0x50 <__bad_interrupt>

00000026 <__trampolines_end>:
  26:	3f 0c       	add	r3, r15
  28:	5b 5e       	subi	r21, 0xEB	; 235
  2a:	6c 76       	andi	r22, 0x6C	; 108
  2c:	77 1c       	adc	r7, r7
  2e:	7f 7e       	andi	r23, 0xEF	; 239

00000030 <__ctors_end>:
  30:	11 24       	eor	r1, r1
  32:	1f be       	out	0x3f, r1	; 63
  34:	cf e5       	ldi	r28, 0x5F	; 95
  36:	d4 e0       	ldi	r29, 0x04	; 4
  38:	de bf       	out	0x3e, r29	; 62
  3a:	cd bf       	out	0x3d, r28	; 61

0000003c <__do_clear_bss>:
  3c:	20 e0       	ldi	r18, 0x00	; 0
  3e:	a0 e6       	ldi	r26, 0x60	; 96
  40:	b0 e0       	ldi	r27, 0x00	; 0
  42:	01 c0       	rjmp	.+2      	; 0x46 <.do_clear_bss_start>

00000044 <.do_clear_bss_loop>:
  44:	1d 92       	st	X+, r1

00000046 <.do_clear_bss_start>:
  46:	a6 38       	cpi	r26, 0x86	; 134
  48:	b2 07       	cpc	r27, r18
  4a:	e1 f7       	brne	.-8      	; 0x44 <.do_clear_bss_loop>
  4c:	35 d4       	rcall	.+2154   	; 0x8b8 <main>
  4e:	55 c5       	rjmp	.+2730   	; 0xafa <_exit>

00000050 <__bad_interrupt>:
  50:	d7 cf       	rjmp	.-82     	; 0x0 <__vectors>

00000052 <digit>:
/// Ï‡ÒÒË‚-˝Í‡Ì

/// Ï‡ÒÒË‚ ÒËÏ‚ÓÎÓ‚-ˆËÙ
const uint8_t digits[] PROGMEM = {d_0,d_1,d_2,d_3,d_4,d_5,d_6,d_7,d_8,d_9};
static uint8_t digit(uint8_t d) 
{
  52:	cf 93       	push	r28
  54:	df 93       	push	r29
  56:	00 d0       	rcall	.+0      	; 0x58 <digit+0x6>
  58:	00 d0       	rcall	.+0      	; 0x5a <digit+0x8>
  5a:	cd b7       	in	r28, 0x3d	; 61
  5c:	de b7       	in	r29, 0x3e	; 62
  5e:	8c 83       	std	Y+4, r24	; 0x04
	return pgm_read_byte(&digits[d]);	
  60:	8c 81       	ldd	r24, Y+4	; 0x04
  62:	88 2f       	mov	r24, r24
  64:	90 e0       	ldi	r25, 0x00	; 0
  66:	8a 5d       	subi	r24, 0xDA	; 218
  68:	9f 4f       	sbci	r25, 0xFF	; 255
  6a:	9a 83       	std	Y+2, r25	; 0x02
  6c:	89 83       	std	Y+1, r24	; 0x01
  6e:	89 81       	ldd	r24, Y+1	; 0x01
  70:	9a 81       	ldd	r25, Y+2	; 0x02
  72:	fc 01       	movw	r30, r24
  74:	84 91       	lpm	r24, Z
  76:	8b 83       	std	Y+3, r24	; 0x03
  78:	8b 81       	ldd	r24, Y+3	; 0x03
}
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	df 91       	pop	r29
  84:	cf 91       	pop	r28
  86:	08 95       	ret

00000088 <SegDyn>:
	
PT_THREAD(SegDyn(struct pt *pt))
{
  88:	ef 92       	push	r14
  8a:	ff 92       	push	r15
  8c:	0f 93       	push	r16
  8e:	1f 93       	push	r17
  90:	cf 93       	push	r28
  92:	df 93       	push	r29
  94:	00 d0       	rcall	.+0      	; 0x96 <SegDyn+0xe>
  96:	1f 92       	push	r1
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
  9c:	9b 83       	std	Y+3, r25	; 0x03
  9e:	8a 83       	std	Y+2, r24	; 0x02
	static volatile uint32_t last_timer=0;
	static volatile uint8_t cathode=0;
	
	PT_BEGIN(pt);
  a0:	81 e0       	ldi	r24, 0x01	; 1
  a2:	89 83       	std	Y+1, r24	; 0x01
  a4:	8a 81       	ldd	r24, Y+2	; 0x02
  a6:	9b 81       	ldd	r25, Y+3	; 0x03
  a8:	fc 01       	movw	r30, r24
  aa:	80 81       	ld	r24, Z
  ac:	91 81       	ldd	r25, Z+1	; 0x01
  ae:	86 32       	cpi	r24, 0x26	; 38
  b0:	91 05       	cpc	r25, r1
  b2:	79 f0       	breq	.+30     	; 0xd2 <SegDyn+0x4a>
  b4:	8b 32       	cpi	r24, 0x2B	; 43
  b6:	91 05       	cpc	r25, r1
  b8:	09 f4       	brne	.+2      	; 0xbc <SegDyn+0x34>
  ba:	4c c0       	rjmp	.+152    	; 0x154 <SegDyn+0xcc>
  bc:	89 2b       	or	r24, r25
  be:	09 f4       	brne	.+2      	; 0xc2 <SegDyn+0x3a>
  c0:	9b c0       	rjmp	.+310    	; 0x1f8 <SegDyn+0x170>
  c2:	a2 c0       	rjmp	.+324    	; 0x208 <SegDyn+0x180>
	while (cathode<SCR_SIZE)
	{
		PT_WAIT_UNTIL(pt, (st_millis()-last_timer)>=5);
  c4:	8a 81       	ldd	r24, Y+2	; 0x02
  c6:	9b 81       	ldd	r25, Y+3	; 0x03
  c8:	26 e2       	ldi	r18, 0x26	; 38
  ca:	30 e0       	ldi	r19, 0x00	; 0
  cc:	fc 01       	movw	r30, r24
  ce:	31 83       	std	Z+1, r19	; 0x01
  d0:	20 83       	st	Z, r18
  d2:	e2 d4       	rcall	.+2500   	; 0xa98 <st_millis>
  d4:	9b 01       	movw	r18, r22
  d6:	ac 01       	movw	r20, r24
  d8:	80 91 60 00 	lds	r24, 0x0060
  dc:	90 91 61 00 	lds	r25, 0x0061
  e0:	a0 91 62 00 	lds	r26, 0x0062
  e4:	b0 91 63 00 	lds	r27, 0x0063
  e8:	79 01       	movw	r14, r18
  ea:	8a 01       	movw	r16, r20
  ec:	e8 1a       	sub	r14, r24
  ee:	f9 0a       	sbc	r15, r25
  f0:	0a 0b       	sbc	r16, r26
  f2:	1b 0b       	sbc	r17, r27
  f4:	d8 01       	movw	r26, r16
  f6:	c7 01       	movw	r24, r14
  f8:	05 97       	sbiw	r24, 0x05	; 5
  fa:	a1 05       	cpc	r26, r1
  fc:	b1 05       	cpc	r27, r1
  fe:	10 f4       	brcc	.+4      	; 0x104 <SegDyn+0x7c>
 100:	80 e0       	ldi	r24, 0x00	; 0
 102:	89 c0       	rjmp	.+274    	; 0x216 <SegDyn+0x18e>
		last_timer=st_millis();
 104:	c9 d4       	rcall	.+2450   	; 0xa98 <st_millis>
 106:	dc 01       	movw	r26, r24
 108:	cb 01       	movw	r24, r22
 10a:	80 93 60 00 	sts	0x0060, r24
 10e:	90 93 61 00 	sts	0x0061, r25
 112:	a0 93 62 00 	sts	0x0062, r26
 116:	b0 93 63 00 	sts	0x0063, r27
		LCD_PORT_1=0;//segments off, CC0 off
 11a:	82 e3       	ldi	r24, 0x32	; 50
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	fc 01       	movw	r30, r24
 120:	10 82       	st	Z, r1
		LCD_PORT_2&=(~(_BV(6))); //CC2, CC3 off (ÛÒÚ‡ÌÓ‚ËÚ¸ ÌÛÎË Ì‡‰Ó)
 122:	88 e3       	ldi	r24, 0x38	; 56
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	28 e3       	ldi	r18, 0x38	; 56
 128:	30 e0       	ldi	r19, 0x00	; 0
 12a:	f9 01       	movw	r30, r18
 12c:	20 81       	ld	r18, Z
 12e:	2f 7b       	andi	r18, 0xBF	; 191
 130:	fc 01       	movw	r30, r24
 132:	20 83       	st	Z, r18
		LCD_PORT_2&=(~(_BV(7)));
 134:	88 e3       	ldi	r24, 0x38	; 56
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	28 e3       	ldi	r18, 0x38	; 56
 13a:	30 e0       	ldi	r19, 0x00	; 0
 13c:	f9 01       	movw	r30, r18
 13e:	20 81       	ld	r18, Z
 140:	2f 77       	andi	r18, 0x7F	; 127
 142:	fc 01       	movw	r30, r24
 144:	20 83       	st	Z, r18
		PT_WAIT_UNTIL(pt, (st_millis()-last_timer)>=1);
 146:	8a 81       	ldd	r24, Y+2	; 0x02
 148:	9b 81       	ldd	r25, Y+3	; 0x03
 14a:	2b e2       	ldi	r18, 0x2B	; 43
 14c:	30 e0       	ldi	r19, 0x00	; 0
 14e:	fc 01       	movw	r30, r24
 150:	31 83       	std	Z+1, r19	; 0x01
 152:	20 83       	st	Z, r18
 154:	a1 d4       	rcall	.+2370   	; 0xa98 <st_millis>
 156:	9b 01       	movw	r18, r22
 158:	ac 01       	movw	r20, r24
 15a:	80 91 60 00 	lds	r24, 0x0060
 15e:	90 91 61 00 	lds	r25, 0x0061
 162:	a0 91 62 00 	lds	r26, 0x0062
 166:	b0 91 63 00 	lds	r27, 0x0063
 16a:	28 17       	cp	r18, r24
 16c:	39 07       	cpc	r19, r25
 16e:	4a 07       	cpc	r20, r26
 170:	5b 07       	cpc	r21, r27
 172:	11 f4       	brne	.+4      	; 0x178 <SegDyn+0xf0>
 174:	80 e0       	ldi	r24, 0x00	; 0
 176:	4f c0       	rjmp	.+158    	; 0x216 <SegDyn+0x18e>
		LCD_PORT_1|=(digit((uint8_t)SCR_D[cathode]));
 178:	80 91 64 00 	lds	r24, 0x0064
 17c:	88 2f       	mov	r24, r24
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	8d 57       	subi	r24, 0x7D	; 125
 182:	9f 4f       	sbci	r25, 0xFF	; 255
 184:	fc 01       	movw	r30, r24
 186:	80 81       	ld	r24, Z
 188:	64 df       	rcall	.-312    	; 0x52 <digit>
 18a:	48 2f       	mov	r20, r24
 18c:	82 e3       	ldi	r24, 0x32	; 50
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	22 e3       	ldi	r18, 0x32	; 50
 192:	30 e0       	ldi	r19, 0x00	; 0
 194:	f9 01       	movw	r30, r18
 196:	20 81       	ld	r18, Z
 198:	24 2b       	or	r18, r20
 19a:	fc 01       	movw	r30, r24
 19c:	20 83       	st	Z, r18
		if (cathode==0) LCD_PORT_1|=(_BV(7));
 19e:	80 91 64 00 	lds	r24, 0x0064
 1a2:	88 23       	and	r24, r24
 1a4:	49 f4       	brne	.+18     	; 0x1b8 <SegDyn+0x130>
 1a6:	82 e3       	ldi	r24, 0x32	; 50
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	22 e3       	ldi	r18, 0x32	; 50
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	f9 01       	movw	r30, r18
 1b0:	20 81       	ld	r18, Z
 1b2:	20 68       	ori	r18, 0x80	; 128
 1b4:	fc 01       	movw	r30, r24
 1b6:	20 83       	st	Z, r18
		if (cathode==1) LCD_PORT_2|=(_BV(6));
 1b8:	80 91 64 00 	lds	r24, 0x0064
 1bc:	81 30       	cpi	r24, 0x01	; 1
 1be:	49 f4       	brne	.+18     	; 0x1d2 <SegDyn+0x14a>
 1c0:	88 e3       	ldi	r24, 0x38	; 56
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	28 e3       	ldi	r18, 0x38	; 56
 1c6:	30 e0       	ldi	r19, 0x00	; 0
 1c8:	f9 01       	movw	r30, r18
 1ca:	20 81       	ld	r18, Z
 1cc:	20 64       	ori	r18, 0x40	; 64
 1ce:	fc 01       	movw	r30, r24
 1d0:	20 83       	st	Z, r18
		if (cathode==2) LCD_PORT_2|=(_BV(7));
 1d2:	80 91 64 00 	lds	r24, 0x0064
 1d6:	82 30       	cpi	r24, 0x02	; 2
 1d8:	49 f4       	brne	.+18     	; 0x1ec <SegDyn+0x164>
 1da:	88 e3       	ldi	r24, 0x38	; 56
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	28 e3       	ldi	r18, 0x38	; 56
 1e0:	30 e0       	ldi	r19, 0x00	; 0
 1e2:	f9 01       	movw	r30, r18
 1e4:	20 81       	ld	r18, Z
 1e6:	20 68       	ori	r18, 0x80	; 128
 1e8:	fc 01       	movw	r30, r24
 1ea:	20 83       	st	Z, r18
		//LCD_PORT_1|=(digit((uint8_t)SCR_D[cathode]));
		cathode++;
 1ec:	80 91 64 00 	lds	r24, 0x0064
 1f0:	8f 5f       	subi	r24, 0xFF	; 255
 1f2:	80 93 64 00 	sts	0x0064, r24
 1f6:	01 c0       	rjmp	.+2      	; 0x1fa <SegDyn+0x172>
{
	static volatile uint32_t last_timer=0;
	static volatile uint8_t cathode=0;
	
	PT_BEGIN(pt);
	while (cathode<SCR_SIZE)
 1f8:	00 00       	nop
 1fa:	80 91 64 00 	lds	r24, 0x0064
 1fe:	83 30       	cpi	r24, 0x03	; 3
 200:	08 f4       	brcc	.+2      	; 0x204 <SegDyn+0x17c>
 202:	60 cf       	rjmp	.-320    	; 0xc4 <SegDyn+0x3c>
		if (cathode==1) LCD_PORT_2|=(_BV(6));
		if (cathode==2) LCD_PORT_2|=(_BV(7));
		//LCD_PORT_1|=(digit((uint8_t)SCR_D[cathode]));
		cathode++;
	}
	cathode=0;
 204:	10 92 64 00 	sts	0x0064, r1
	PT_END(pt);
 208:	19 82       	std	Y+1, r1	; 0x01
 20a:	8a 81       	ldd	r24, Y+2	; 0x02
 20c:	9b 81       	ldd	r25, Y+3	; 0x03
 20e:	fc 01       	movw	r30, r24
 210:	11 82       	std	Z+1, r1	; 0x01
 212:	10 82       	st	Z, r1
 214:	83 e0       	ldi	r24, 0x03	; 3
}
 216:	0f 90       	pop	r0
 218:	0f 90       	pop	r0
 21a:	0f 90       	pop	r0
 21c:	df 91       	pop	r29
 21e:	cf 91       	pop	r28
 220:	1f 91       	pop	r17
 222:	0f 91       	pop	r16
 224:	ff 90       	pop	r15
 226:	ef 90       	pop	r14
 228:	08 95       	ret

0000022a <EncoderButton>:
	EncoderValue=EncVal;
	
	PT_END(pt);
}
PT_THREAD(EncoderButton(struct pt *pt))
{
 22a:	ef 92       	push	r14
 22c:	ff 92       	push	r15
 22e:	0f 93       	push	r16
 230:	1f 93       	push	r17
 232:	cf 93       	push	r28
 234:	df 93       	push	r29
 236:	00 d0       	rcall	.+0      	; 0x238 <EncoderButton+0xe>
 238:	1f 92       	push	r1
 23a:	cd b7       	in	r28, 0x3d	; 61
 23c:	de b7       	in	r29, 0x3e	; 62
 23e:	9b 83       	std	Y+3, r25	; 0x03
 240:	8a 83       	std	Y+2, r24	; 0x02
	static uint32_t but_timer=0;
	static uint16_t val=0;
	PT_BEGIN(pt);
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	89 83       	std	Y+1, r24	; 0x01
 246:	8a 81       	ldd	r24, Y+2	; 0x02
 248:	9b 81       	ldd	r25, Y+3	; 0x03
 24a:	fc 01       	movw	r30, r24
 24c:	80 81       	ld	r24, Z
 24e:	91 81       	ldd	r25, Z+1	; 0x01
 250:	87 33       	cpi	r24, 0x37	; 55
 252:	91 05       	cpc	r25, r1
 254:	71 f0       	breq	.+28     	; 0x272 <EncoderButton+0x48>
 256:	82 34       	cpi	r24, 0x42	; 66
 258:	91 05       	cpc	r25, r1
 25a:	09 f4       	brne	.+2      	; 0x25e <EncoderButton+0x34>
 25c:	53 c0       	rjmp	.+166    	; 0x304 <EncoderButton+0xda>
 25e:	89 2b       	or	r24, r25
 260:	09 f0       	breq	.+2      	; 0x264 <EncoderButton+0x3a>
 262:	6e c0       	rjmp	.+220    	; 0x340 <EncoderButton+0x116>
	PT_WAIT_UNTIL(pt, (st_millis()-but_timer)>=1);
 264:	8a 81       	ldd	r24, Y+2	; 0x02
 266:	9b 81       	ldd	r25, Y+3	; 0x03
 268:	27 e3       	ldi	r18, 0x37	; 55
 26a:	30 e0       	ldi	r19, 0x00	; 0
 26c:	fc 01       	movw	r30, r24
 26e:	31 83       	std	Z+1, r19	; 0x01
 270:	20 83       	st	Z, r18
 272:	12 d4       	rcall	.+2084   	; 0xa98 <st_millis>
 274:	9b 01       	movw	r18, r22
 276:	ac 01       	movw	r20, r24
 278:	80 91 66 00 	lds	r24, 0x0066
 27c:	90 91 67 00 	lds	r25, 0x0067
 280:	a0 91 68 00 	lds	r26, 0x0068
 284:	b0 91 69 00 	lds	r27, 0x0069
 288:	28 17       	cp	r18, r24
 28a:	39 07       	cpc	r19, r25
 28c:	4a 07       	cpc	r20, r26
 28e:	5b 07       	cpc	r21, r27
 290:	11 f4       	brne	.+4      	; 0x296 <EncoderButton+0x6c>
 292:	80 e0       	ldi	r24, 0x00	; 0
 294:	5c c0       	rjmp	.+184    	; 0x34e <EncoderButton+0x124>
	but_timer=st_millis();
 296:	00 d4       	rcall	.+2048   	; 0xa98 <st_millis>
 298:	dc 01       	movw	r26, r24
 29a:	cb 01       	movw	r24, r22
 29c:	80 93 66 00 	sts	0x0066, r24
 2a0:	90 93 67 00 	sts	0x0067, r25
 2a4:	a0 93 68 00 	sts	0x0068, r26
 2a8:	b0 93 69 00 	sts	0x0069, r27
	if (((PIN(ENCBUT_PORT)&(_BV(ENCBUT_PIN)))==0)&&(val<=1000))
 2ac:	86 e3       	ldi	r24, 0x36	; 54
 2ae:	90 e0       	ldi	r25, 0x00	; 0
 2b0:	fc 01       	movw	r30, r24
 2b2:	80 81       	ld	r24, Z
 2b4:	88 2f       	mov	r24, r24
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	80 72       	andi	r24, 0x20	; 32
 2ba:	99 27       	eor	r25, r25
 2bc:	89 2b       	or	r24, r25
 2be:	89 f4       	brne	.+34     	; 0x2e2 <EncoderButton+0xb8>
 2c0:	80 91 6a 00 	lds	r24, 0x006A
 2c4:	90 91 6b 00 	lds	r25, 0x006B
 2c8:	89 3e       	cpi	r24, 0xE9	; 233
 2ca:	93 40       	sbci	r25, 0x03	; 3
 2cc:	50 f4       	brcc	.+20     	; 0x2e2 <EncoderButton+0xb8>
	{
		val++;
 2ce:	80 91 6a 00 	lds	r24, 0x006A
 2d2:	90 91 6b 00 	lds	r25, 0x006B
 2d6:	01 96       	adiw	r24, 0x01	; 1
 2d8:	90 93 6b 00 	sts	0x006B, r25
 2dc:	80 93 6a 00 	sts	0x006A, r24
 2e0:	2f c0       	rjmp	.+94     	; 0x340 <EncoderButton+0x116>
	}
	else
	{
		if (val>900)
 2e2:	80 91 6a 00 	lds	r24, 0x006A
 2e6:	90 91 6b 00 	lds	r25, 0x006B
 2ea:	85 38       	cpi	r24, 0x85	; 133
 2ec:	93 40       	sbci	r25, 0x03	; 3
 2ee:	20 f1       	brcs	.+72     	; 0x338 <EncoderButton+0x10e>
		{
			ButtonState=BUTTON_LONG_ON;
 2f0:	82 e0       	ldi	r24, 0x02	; 2
 2f2:	80 93 65 00 	sts	0x0065, r24
			PT_WAIT_UNTIL(pt,(st_millis()-but_timer)>=1000);
 2f6:	8a 81       	ldd	r24, Y+2	; 0x02
 2f8:	9b 81       	ldd	r25, Y+3	; 0x03
 2fa:	22 e4       	ldi	r18, 0x42	; 66
 2fc:	30 e0       	ldi	r19, 0x00	; 0
 2fe:	fc 01       	movw	r30, r24
 300:	31 83       	std	Z+1, r19	; 0x01
 302:	20 83       	st	Z, r18
 304:	c9 d3       	rcall	.+1938   	; 0xa98 <st_millis>
 306:	9b 01       	movw	r18, r22
 308:	ac 01       	movw	r20, r24
 30a:	80 91 66 00 	lds	r24, 0x0066
 30e:	90 91 67 00 	lds	r25, 0x0067
 312:	a0 91 68 00 	lds	r26, 0x0068
 316:	b0 91 69 00 	lds	r27, 0x0069
 31a:	79 01       	movw	r14, r18
 31c:	8a 01       	movw	r16, r20
 31e:	e8 1a       	sub	r14, r24
 320:	f9 0a       	sbc	r15, r25
 322:	0a 0b       	sbc	r16, r26
 324:	1b 0b       	sbc	r17, r27
 326:	d8 01       	movw	r26, r16
 328:	c7 01       	movw	r24, r14
 32a:	88 3e       	cpi	r24, 0xE8	; 232
 32c:	93 40       	sbci	r25, 0x03	; 3
 32e:	a1 05       	cpc	r26, r1
 330:	b1 05       	cpc	r27, r1
 332:	10 f4       	brcc	.+4      	; 0x338 <EncoderButton+0x10e>
 334:	80 e0       	ldi	r24, 0x00	; 0
 336:	0b c0       	rjmp	.+22     	; 0x34e <EncoderButton+0x124>
		}
		else if (val>=5)
		{
			//button_change_state();
		}
		val=0;
 338:	10 92 6b 00 	sts	0x006B, r1
 33c:	10 92 6a 00 	sts	0x006A, r1
	}
	PT_END(pt);
 340:	19 82       	std	Y+1, r1	; 0x01
 342:	8a 81       	ldd	r24, Y+2	; 0x02
 344:	9b 81       	ldd	r25, Y+3	; 0x03
 346:	fc 01       	movw	r30, r24
 348:	11 82       	std	Z+1, r1	; 0x01
 34a:	10 82       	st	Z, r1
 34c:	83 e0       	ldi	r24, 0x03	; 3
}
 34e:	0f 90       	pop	r0
 350:	0f 90       	pop	r0
 352:	0f 90       	pop	r0
 354:	df 91       	pop	r29
 356:	cf 91       	pop	r28
 358:	1f 91       	pop	r17
 35a:	0f 91       	pop	r16
 35c:	ff 90       	pop	r15
 35e:	ef 90       	pop	r14
 360:	08 95       	ret

00000362 <divmodu10>:
volatile uint8_t SCR_D[SCR_SIZE];
static struct PID_DATA *pid_reg_st;


inline static struct divmod10_t divmodu10(uint32_t n)
{
 362:	2f 92       	push	r2
 364:	3f 92       	push	r3
 366:	4f 92       	push	r4
 368:	5f 92       	push	r5
 36a:	6f 92       	push	r6
 36c:	7f 92       	push	r7
 36e:	8f 92       	push	r8
 370:	9f 92       	push	r9
 372:	af 92       	push	r10
 374:	bf 92       	push	r11
 376:	cf 92       	push	r12
 378:	df 92       	push	r13
 37a:	ef 92       	push	r14
 37c:	ff 92       	push	r15
 37e:	0f 93       	push	r16
 380:	1f 93       	push	r17
 382:	cf 93       	push	r28
 384:	df 93       	push	r29
 386:	cd b7       	in	r28, 0x3d	; 61
 388:	de b7       	in	r29, 0x3e	; 62
 38a:	62 97       	sbiw	r28, 0x12	; 18
 38c:	0f b6       	in	r0, 0x3f	; 63
 38e:	f8 94       	cli
 390:	de bf       	out	0x3e, r29	; 62
 392:	0f be       	out	0x3f, r0	; 63
 394:	cd bf       	out	0x3d, r28	; 61
 396:	6f 87       	std	Y+15, r22	; 0x0f
 398:	78 8b       	std	Y+16, r23	; 0x10
 39a:	89 8b       	std	Y+17, r24	; 0x11
 39c:	9a 8b       	std	Y+18, r25	; 0x12
	struct divmod10_t res;
	// —É–º–Ω–æ–∂–∞–µ–º –Ω–∞ 0.8
	res.quot = n >> 1;
 39e:	8f 85       	ldd	r24, Y+15	; 0x0f
 3a0:	98 89       	ldd	r25, Y+16	; 0x10
 3a2:	a9 89       	ldd	r26, Y+17	; 0x11
 3a4:	ba 89       	ldd	r27, Y+18	; 0x12
 3a6:	b6 95       	lsr	r27
 3a8:	a7 95       	ror	r26
 3aa:	97 95       	ror	r25
 3ac:	87 95       	ror	r24
 3ae:	8a 87       	std	Y+10, r24	; 0x0a
 3b0:	9b 87       	std	Y+11, r25	; 0x0b
 3b2:	ac 87       	std	Y+12, r26	; 0x0c
 3b4:	bd 87       	std	Y+13, r27	; 0x0d
	res.quot += res.quot >> 1;
 3b6:	2a 85       	ldd	r18, Y+10	; 0x0a
 3b8:	3b 85       	ldd	r19, Y+11	; 0x0b
 3ba:	4c 85       	ldd	r20, Y+12	; 0x0c
 3bc:	5d 85       	ldd	r21, Y+13	; 0x0d
 3be:	8a 85       	ldd	r24, Y+10	; 0x0a
 3c0:	9b 85       	ldd	r25, Y+11	; 0x0b
 3c2:	ac 85       	ldd	r26, Y+12	; 0x0c
 3c4:	bd 85       	ldd	r27, Y+13	; 0x0d
 3c6:	b6 95       	lsr	r27
 3c8:	a7 95       	ror	r26
 3ca:	97 95       	ror	r25
 3cc:	87 95       	ror	r24
 3ce:	82 0f       	add	r24, r18
 3d0:	93 1f       	adc	r25, r19
 3d2:	a4 1f       	adc	r26, r20
 3d4:	b5 1f       	adc	r27, r21
 3d6:	8a 87       	std	Y+10, r24	; 0x0a
 3d8:	9b 87       	std	Y+11, r25	; 0x0b
 3da:	ac 87       	std	Y+12, r26	; 0x0c
 3dc:	bd 87       	std	Y+13, r27	; 0x0d
	res.quot += res.quot >> 4;
 3de:	2a 85       	ldd	r18, Y+10	; 0x0a
 3e0:	3b 85       	ldd	r19, Y+11	; 0x0b
 3e2:	4c 85       	ldd	r20, Y+12	; 0x0c
 3e4:	5d 85       	ldd	r21, Y+13	; 0x0d
 3e6:	8a 85       	ldd	r24, Y+10	; 0x0a
 3e8:	9b 85       	ldd	r25, Y+11	; 0x0b
 3ea:	ac 85       	ldd	r26, Y+12	; 0x0c
 3ec:	bd 85       	ldd	r27, Y+13	; 0x0d
 3ee:	68 94       	set
 3f0:	13 f8       	bld	r1, 3
 3f2:	b6 95       	lsr	r27
 3f4:	a7 95       	ror	r26
 3f6:	97 95       	ror	r25
 3f8:	87 95       	ror	r24
 3fa:	16 94       	lsr	r1
 3fc:	d1 f7       	brne	.-12     	; 0x3f2 <divmodu10+0x90>
 3fe:	82 0f       	add	r24, r18
 400:	93 1f       	adc	r25, r19
 402:	a4 1f       	adc	r26, r20
 404:	b5 1f       	adc	r27, r21
 406:	8a 87       	std	Y+10, r24	; 0x0a
 408:	9b 87       	std	Y+11, r25	; 0x0b
 40a:	ac 87       	std	Y+12, r26	; 0x0c
 40c:	bd 87       	std	Y+13, r27	; 0x0d
	res.quot += res.quot >> 8;
 40e:	2a 85       	ldd	r18, Y+10	; 0x0a
 410:	3b 85       	ldd	r19, Y+11	; 0x0b
 412:	4c 85       	ldd	r20, Y+12	; 0x0c
 414:	5d 85       	ldd	r21, Y+13	; 0x0d
 416:	8a 85       	ldd	r24, Y+10	; 0x0a
 418:	9b 85       	ldd	r25, Y+11	; 0x0b
 41a:	ac 85       	ldd	r26, Y+12	; 0x0c
 41c:	bd 85       	ldd	r27, Y+13	; 0x0d
 41e:	89 2f       	mov	r24, r25
 420:	9a 2f       	mov	r25, r26
 422:	ab 2f       	mov	r26, r27
 424:	bb 27       	eor	r27, r27
 426:	82 0f       	add	r24, r18
 428:	93 1f       	adc	r25, r19
 42a:	a4 1f       	adc	r26, r20
 42c:	b5 1f       	adc	r27, r21
 42e:	8a 87       	std	Y+10, r24	; 0x0a
 430:	9b 87       	std	Y+11, r25	; 0x0b
 432:	ac 87       	std	Y+12, r26	; 0x0c
 434:	bd 87       	std	Y+13, r27	; 0x0d
	res.quot += res.quot >> 16;
 436:	2a 85       	ldd	r18, Y+10	; 0x0a
 438:	3b 85       	ldd	r19, Y+11	; 0x0b
 43a:	4c 85       	ldd	r20, Y+12	; 0x0c
 43c:	5d 85       	ldd	r21, Y+13	; 0x0d
 43e:	8a 85       	ldd	r24, Y+10	; 0x0a
 440:	9b 85       	ldd	r25, Y+11	; 0x0b
 442:	ac 85       	ldd	r26, Y+12	; 0x0c
 444:	bd 85       	ldd	r27, Y+13	; 0x0d
 446:	cd 01       	movw	r24, r26
 448:	aa 27       	eor	r26, r26
 44a:	bb 27       	eor	r27, r27
 44c:	82 0f       	add	r24, r18
 44e:	93 1f       	adc	r25, r19
 450:	a4 1f       	adc	r26, r20
 452:	b5 1f       	adc	r27, r21
 454:	8a 87       	std	Y+10, r24	; 0x0a
 456:	9b 87       	std	Y+11, r25	; 0x0b
 458:	ac 87       	std	Y+12, r26	; 0x0c
 45a:	bd 87       	std	Y+13, r27	; 0x0d
	uint32_t qq = res.quot;
 45c:	8a 85       	ldd	r24, Y+10	; 0x0a
 45e:	9b 85       	ldd	r25, Y+11	; 0x0b
 460:	ac 85       	ldd	r26, Y+12	; 0x0c
 462:	bd 85       	ldd	r27, Y+13	; 0x0d
 464:	89 83       	std	Y+1, r24	; 0x01
 466:	9a 83       	std	Y+2, r25	; 0x02
 468:	ab 83       	std	Y+3, r26	; 0x03
 46a:	bc 83       	std	Y+4, r27	; 0x04
	// –¥–µ–ª–∏–º –Ω–∞ 8
	res.quot >>= 3;
 46c:	8a 85       	ldd	r24, Y+10	; 0x0a
 46e:	9b 85       	ldd	r25, Y+11	; 0x0b
 470:	ac 85       	ldd	r26, Y+12	; 0x0c
 472:	bd 85       	ldd	r27, Y+13	; 0x0d
 474:	68 94       	set
 476:	12 f8       	bld	r1, 2
 478:	b6 95       	lsr	r27
 47a:	a7 95       	ror	r26
 47c:	97 95       	ror	r25
 47e:	87 95       	ror	r24
 480:	16 94       	lsr	r1
 482:	d1 f7       	brne	.-12     	; 0x478 <__stack+0x19>
 484:	8a 87       	std	Y+10, r24	; 0x0a
 486:	9b 87       	std	Y+11, r25	; 0x0b
 488:	ac 87       	std	Y+12, r26	; 0x0c
 48a:	bd 87       	std	Y+13, r27	; 0x0d
	// –≤—ã—á–∏—Å–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫
	res.rem = (uint8_t)(n - ((res.quot << 1) + (qq & ~7ul)));
 48c:	2f 85       	ldd	r18, Y+15	; 0x0f
 48e:	8a 85       	ldd	r24, Y+10	; 0x0a
 490:	9b 85       	ldd	r25, Y+11	; 0x0b
 492:	ac 85       	ldd	r26, Y+12	; 0x0c
 494:	bd 85       	ldd	r27, Y+13	; 0x0d
 496:	98 2f       	mov	r25, r24
 498:	99 0f       	add	r25, r25
 49a:	89 81       	ldd	r24, Y+1	; 0x01
 49c:	88 7f       	andi	r24, 0xF8	; 248
 49e:	89 0f       	add	r24, r25
 4a0:	92 2f       	mov	r25, r18
 4a2:	98 1b       	sub	r25, r24
 4a4:	89 2f       	mov	r24, r25
 4a6:	8e 87       	std	Y+14, r24	; 0x0e
	// –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –∏ —á–∞—Å—Ç–Ω–æ–µ
	if(res.rem > 9)
 4a8:	8e 85       	ldd	r24, Y+14	; 0x0e
 4aa:	8a 30       	cpi	r24, 0x0A	; 10
 4ac:	70 f0       	brcs	.+28     	; 0x4ca <__stack+0x6b>
	{
		res.rem -= 10;
 4ae:	8e 85       	ldd	r24, Y+14	; 0x0e
 4b0:	8a 50       	subi	r24, 0x0A	; 10
 4b2:	8e 87       	std	Y+14, r24	; 0x0e
		res.quot++;
 4b4:	8a 85       	ldd	r24, Y+10	; 0x0a
 4b6:	9b 85       	ldd	r25, Y+11	; 0x0b
 4b8:	ac 85       	ldd	r26, Y+12	; 0x0c
 4ba:	bd 85       	ldd	r27, Y+13	; 0x0d
 4bc:	01 96       	adiw	r24, 0x01	; 1
 4be:	a1 1d       	adc	r26, r1
 4c0:	b1 1d       	adc	r27, r1
 4c2:	8a 87       	std	Y+10, r24	; 0x0a
 4c4:	9b 87       	std	Y+11, r25	; 0x0b
 4c6:	ac 87       	std	Y+12, r26	; 0x0c
 4c8:	bd 87       	std	Y+13, r27	; 0x0d
	}
	return res;
 4ca:	85 e0       	ldi	r24, 0x05	; 5
 4cc:	fe 01       	movw	r30, r28
 4ce:	3a 96       	adiw	r30, 0x0a	; 10
 4d0:	de 01       	movw	r26, r28
 4d2:	15 96       	adiw	r26, 0x05	; 5
 4d4:	01 90       	ld	r0, Z+
 4d6:	0d 92       	st	X+, r0
 4d8:	8a 95       	dec	r24
 4da:	e1 f7       	brne	.-8      	; 0x4d4 <__stack+0x75>
 4dc:	40 e0       	ldi	r20, 0x00	; 0
 4de:	4d 81       	ldd	r20, Y+5	; 0x05
 4e0:	30 e0       	ldi	r19, 0x00	; 0
 4e2:	3e 81       	ldd	r19, Y+6	; 0x06
 4e4:	20 e0       	ldi	r18, 0x00	; 0
 4e6:	2f 81       	ldd	r18, Y+7	; 0x07
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	98 85       	ldd	r25, Y+8	; 0x08
 4ec:	80 e0       	ldi	r24, 0x00	; 0
 4ee:	89 85       	ldd	r24, Y+9	; 0x09
 4f0:	24 2e       	mov	r2, r20
 4f2:	33 2e       	mov	r3, r19
 4f4:	42 2e       	mov	r4, r18
 4f6:	59 2e       	mov	r5, r25
 4f8:	68 2e       	mov	r6, r24
 4fa:	a2 2c       	mov	r10, r2
 4fc:	b3 2c       	mov	r11, r3
 4fe:	c4 2c       	mov	r12, r4
 500:	d5 2c       	mov	r13, r5
 502:	e6 2c       	mov	r14, r6
 504:	f7 2c       	mov	r15, r7
 506:	08 2d       	mov	r16, r8
 508:	19 2d       	mov	r17, r9
}
 50a:	2a 2d       	mov	r18, r10
 50c:	3b 2d       	mov	r19, r11
 50e:	4c 2d       	mov	r20, r12
 510:	5d 2d       	mov	r21, r13
 512:	6e 2d       	mov	r22, r14
 514:	7f 2d       	mov	r23, r15
 516:	80 2f       	mov	r24, r16
 518:	91 2f       	mov	r25, r17
 51a:	62 96       	adiw	r28, 0x12	; 18
 51c:	0f b6       	in	r0, 0x3f	; 63
 51e:	f8 94       	cli
 520:	de bf       	out	0x3e, r29	; 62
 522:	0f be       	out	0x3f, r0	; 63
 524:	cd bf       	out	0x3d, r28	; 61
 526:	df 91       	pop	r29
 528:	cf 91       	pop	r28
 52a:	1f 91       	pop	r17
 52c:	0f 91       	pop	r16
 52e:	ff 90       	pop	r15
 530:	ef 90       	pop	r14
 532:	df 90       	pop	r13
 534:	cf 90       	pop	r12
 536:	bf 90       	pop	r11
 538:	af 90       	pop	r10
 53a:	9f 90       	pop	r9
 53c:	8f 90       	pop	r8
 53e:	7f 90       	pop	r7
 540:	6f 90       	pop	r6
 542:	5f 90       	pop	r5
 544:	4f 90       	pop	r4
 546:	3f 90       	pop	r3
 548:	2f 90       	pop	r2
 54a:	08 95       	ret

0000054c <utoa_fast_div>:

char * utoa_fast_div(uint32_t value, uint8_t *buffer)
{
 54c:	af 92       	push	r10
 54e:	bf 92       	push	r11
 550:	cf 92       	push	r12
 552:	df 92       	push	r13
 554:	ef 92       	push	r14
 556:	ff 92       	push	r15
 558:	0f 93       	push	r16
 55a:	1f 93       	push	r17
 55c:	cf 93       	push	r28
 55e:	df 93       	push	r29
 560:	cd b7       	in	r28, 0x3d	; 61
 562:	de b7       	in	r29, 0x3e	; 62
 564:	2b 97       	sbiw	r28, 0x0b	; 11
 566:	0f b6       	in	r0, 0x3f	; 63
 568:	f8 94       	cli
 56a:	de bf       	out	0x3e, r29	; 62
 56c:	0f be       	out	0x3f, r0	; 63
 56e:	cd bf       	out	0x3d, r28	; 61
 570:	6e 83       	std	Y+6, r22	; 0x06
 572:	7f 83       	std	Y+7, r23	; 0x07
 574:	88 87       	std	Y+8, r24	; 0x08
 576:	99 87       	std	Y+9, r25	; 0x09
 578:	5b 87       	std	Y+11, r21	; 0x0b
 57a:	4a 87       	std	Y+10, r20	; 0x0a
	
	//uint8_t i=0;
	buffer += LCD_BUF_SIZE;//—É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –º–ª–∞–¥—à–∏–π —Ä–∞–∑—Ä—è–¥ +1
 57c:	8a 85       	ldd	r24, Y+10	; 0x0a
 57e:	9b 85       	ldd	r25, Y+11	; 0x0b
 580:	04 96       	adiw	r24, 0x04	; 4
 582:	9b 87       	std	Y+11, r25	; 0x0b
 584:	8a 87       	std	Y+10, r24	; 0x0a
	*--buffer = 0;//–≤—ã—á–∏—Ç–∞–µ–º –∏–∑ –∞–¥—Ä–µ—Å–∞ 1 –∏ –∫–ª–∞–¥–µ–º –≤ –º–ª–∞–¥—à–∏–π —Ä–∞–∑—Ä—è–¥ 0
 586:	8a 85       	ldd	r24, Y+10	; 0x0a
 588:	9b 85       	ldd	r25, Y+11	; 0x0b
 58a:	01 97       	sbiw	r24, 0x01	; 1
 58c:	9b 87       	std	Y+11, r25	; 0x0b
 58e:	8a 87       	std	Y+10, r24	; 0x0a
 590:	8a 85       	ldd	r24, Y+10	; 0x0a
 592:	9b 85       	ldd	r25, Y+11	; 0x0b
 594:	fc 01       	movw	r30, r24
 596:	10 82       	st	Z, r1
	do
	{
		struct divmod10_t res = divmodu10(value);
 598:	8e 81       	ldd	r24, Y+6	; 0x06
 59a:	9f 81       	ldd	r25, Y+7	; 0x07
 59c:	a8 85       	ldd	r26, Y+8	; 0x08
 59e:	b9 85       	ldd	r27, Y+9	; 0x09
 5a0:	bc 01       	movw	r22, r24
 5a2:	cd 01       	movw	r24, r26
 5a4:	de de       	rcall	.-580    	; 0x362 <divmodu10>
 5a6:	a2 2e       	mov	r10, r18
 5a8:	b3 2e       	mov	r11, r19
 5aa:	c4 2e       	mov	r12, r20
 5ac:	d5 2e       	mov	r13, r21
 5ae:	e6 2e       	mov	r14, r22
 5b0:	f7 2e       	mov	r15, r23
 5b2:	08 2f       	mov	r16, r24
 5b4:	19 2f       	mov	r17, r25
 5b6:	2a 2d       	mov	r18, r10
 5b8:	3b 2d       	mov	r19, r11
 5ba:	4c 2d       	mov	r20, r12
 5bc:	5d 2d       	mov	r21, r13
 5be:	6e 2d       	mov	r22, r14
 5c0:	7f 2d       	mov	r23, r15
 5c2:	80 2f       	mov	r24, r16
 5c4:	91 2f       	mov	r25, r17
 5c6:	29 83       	std	Y+1, r18	; 0x01
 5c8:	3a 83       	std	Y+2, r19	; 0x02
 5ca:	4b 83       	std	Y+3, r20	; 0x03
 5cc:	5c 83       	std	Y+4, r21	; 0x04
 5ce:	6d 83       	std	Y+5, r22	; 0x05
		*--buffer = res.rem;
 5d0:	8a 85       	ldd	r24, Y+10	; 0x0a
 5d2:	9b 85       	ldd	r25, Y+11	; 0x0b
 5d4:	01 97       	sbiw	r24, 0x01	; 1
 5d6:	9b 87       	std	Y+11, r25	; 0x0b
 5d8:	8a 87       	std	Y+10, r24	; 0x0a
 5da:	2d 81       	ldd	r18, Y+5	; 0x05
 5dc:	8a 85       	ldd	r24, Y+10	; 0x0a
 5de:	9b 85       	ldd	r25, Y+11	; 0x0b
 5e0:	fc 01       	movw	r30, r24
 5e2:	20 83       	st	Z, r18
		//*buffer = res.rem + '0';
		//buffer--;
		value = res.quot;
 5e4:	89 81       	ldd	r24, Y+1	; 0x01
 5e6:	9a 81       	ldd	r25, Y+2	; 0x02
 5e8:	ab 81       	ldd	r26, Y+3	; 0x03
 5ea:	bc 81       	ldd	r27, Y+4	; 0x04
 5ec:	8e 83       	std	Y+6, r24	; 0x06
 5ee:	9f 83       	std	Y+7, r25	; 0x07
 5f0:	a8 87       	std	Y+8, r26	; 0x08
 5f2:	b9 87       	std	Y+9, r27	; 0x09
		//i++;
	}
	while (value != 0);
 5f4:	8e 81       	ldd	r24, Y+6	; 0x06
 5f6:	9f 81       	ldd	r25, Y+7	; 0x07
 5f8:	a8 85       	ldd	r26, Y+8	; 0x08
 5fa:	b9 85       	ldd	r27, Y+9	; 0x09
 5fc:	89 2b       	or	r24, r25
 5fe:	8a 2b       	or	r24, r26
 600:	8b 2b       	or	r24, r27
 602:	51 f6       	brne	.-108    	; 0x598 <utoa_fast_div+0x4c>
	//if (i==1) {*(buffer-3)=0; *(buffer-2)=0;}
	//else if (i==2) {*(buffer-2)=0;}
	
	return (char *)buffer; 
 604:	8a 85       	ldd	r24, Y+10	; 0x0a
 606:	9b 85       	ldd	r25, Y+11	; 0x0b
}
 608:	2b 96       	adiw	r28, 0x0b	; 11
 60a:	0f b6       	in	r0, 0x3f	; 63
 60c:	f8 94       	cli
 60e:	de bf       	out	0x3e, r29	; 62
 610:	0f be       	out	0x3f, r0	; 63
 612:	cd bf       	out	0x3d, r28	; 61
 614:	df 91       	pop	r29
 616:	cf 91       	pop	r28
 618:	1f 91       	pop	r17
 61a:	0f 91       	pop	r16
 61c:	ff 90       	pop	r15
 61e:	ef 90       	pop	r14
 620:	df 90       	pop	r13
 622:	cf 90       	pop	r12
 624:	bf 90       	pop	r11
 626:	af 90       	pop	r10
 628:	08 95       	ret

0000062a <ADC_LCD>:
	
	PT_END(pt);
		
}
PT_THREAD(ADC_LCD(struct pt *pt))
{
 62a:	ef 92       	push	r14
 62c:	ff 92       	push	r15
 62e:	0f 93       	push	r16
 630:	1f 93       	push	r17
 632:	cf 93       	push	r28
 634:	df 93       	push	r29
 636:	00 d0       	rcall	.+0      	; 0x638 <ADC_LCD+0xe>
 638:	00 d0       	rcall	.+0      	; 0x63a <ADC_LCD+0x10>
 63a:	1f 92       	push	r1
 63c:	cd b7       	in	r28, 0x3d	; 61
 63e:	de b7       	in	r29, 0x3e	; 62
 640:	9d 83       	std	Y+5, r25	; 0x05
 642:	8c 83       	std	Y+4, r24	; 0x04
	static volatile uint8_t adc_lcd_timer=0, averaging=0;
	static volatile uint32_t aver_value=0;
	volatile uint8_t *ptr;
	PT_BEGIN(pt);
 644:	81 e0       	ldi	r24, 0x01	; 1
 646:	89 83       	std	Y+1, r24	; 0x01
 648:	8c 81       	ldd	r24, Y+4	; 0x04
 64a:	9d 81       	ldd	r25, Y+5	; 0x05
 64c:	fc 01       	movw	r30, r24
 64e:	80 81       	ld	r24, Z
 650:	91 81       	ldd	r25, Z+1	; 0x01
 652:	00 97       	sbiw	r24, 0x00	; 0
 654:	21 f0       	breq	.+8      	; 0x65e <ADC_LCD+0x34>
 656:	88 3a       	cpi	r24, 0xA8	; 168
 658:	91 05       	cpc	r25, r1
 65a:	41 f0       	breq	.+16     	; 0x66c <ADC_LCD+0x42>
 65c:	89 c0       	rjmp	.+274    	; 0x770 <ADC_LCD+0x146>
	PT_WAIT_UNTIL(pt,(st_millis()-adc_lcd_timer)>=10);
 65e:	8c 81       	ldd	r24, Y+4	; 0x04
 660:	9d 81       	ldd	r25, Y+5	; 0x05
 662:	28 ea       	ldi	r18, 0xA8	; 168
 664:	30 e0       	ldi	r19, 0x00	; 0
 666:	fc 01       	movw	r30, r24
 668:	31 83       	std	Z+1, r19	; 0x01
 66a:	20 83       	st	Z, r18
 66c:	15 d2       	rcall	.+1066   	; 0xa98 <st_millis>
 66e:	9b 01       	movw	r18, r22
 670:	ac 01       	movw	r20, r24
 672:	80 91 79 00 	lds	r24, 0x0079
 676:	88 2f       	mov	r24, r24
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	a0 e0       	ldi	r26, 0x00	; 0
 67c:	b0 e0       	ldi	r27, 0x00	; 0
 67e:	79 01       	movw	r14, r18
 680:	8a 01       	movw	r16, r20
 682:	e8 1a       	sub	r14, r24
 684:	f9 0a       	sbc	r15, r25
 686:	0a 0b       	sbc	r16, r26
 688:	1b 0b       	sbc	r17, r27
 68a:	d8 01       	movw	r26, r16
 68c:	c7 01       	movw	r24, r14
 68e:	0a 97       	sbiw	r24, 0x0a	; 10
 690:	a1 05       	cpc	r26, r1
 692:	b1 05       	cpc	r27, r1
 694:	10 f4       	brcc	.+4      	; 0x69a <ADC_LCD+0x70>
 696:	80 e0       	ldi	r24, 0x00	; 0
 698:	72 c0       	rjmp	.+228    	; 0x77e <ADC_LCD+0x154>
	//MCUCR|=0b10000000;//–∂–¥–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ—Ç –ê–¶–ü –≤ —Å–ø—è—á–∫–µ
	sleep_enable();
 69a:	85 e5       	ldi	r24, 0x55	; 85
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	25 e5       	ldi	r18, 0x55	; 85
 6a0:	30 e0       	ldi	r19, 0x00	; 0
 6a2:	f9 01       	movw	r30, r18
 6a4:	20 81       	ld	r18, Z
 6a6:	20 68       	ori	r18, 0x80	; 128
 6a8:	fc 01       	movw	r30, r24
 6aa:	20 83       	st	Z, r18
	ADCSRA|=(_BV(7))|(_BV(6));//–∑–∞—É–ø—Å–∫ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ê–¶–ü
 6ac:	86 e2       	ldi	r24, 0x26	; 38
 6ae:	90 e0       	ldi	r25, 0x00	; 0
 6b0:	26 e2       	ldi	r18, 0x26	; 38
 6b2:	30 e0       	ldi	r19, 0x00	; 0
 6b4:	f9 01       	movw	r30, r18
 6b6:	20 81       	ld	r18, Z
 6b8:	20 6c       	ori	r18, 0xC0	; 192
 6ba:	fc 01       	movw	r30, r24
 6bc:	20 83       	st	Z, r18
	sleep_cpu();
 6be:	88 95       	sleep
	sleep_disable();
 6c0:	85 e5       	ldi	r24, 0x55	; 85
 6c2:	90 e0       	ldi	r25, 0x00	; 0
 6c4:	25 e5       	ldi	r18, 0x55	; 85
 6c6:	30 e0       	ldi	r19, 0x00	; 0
 6c8:	f9 01       	movw	r30, r18
 6ca:	20 81       	ld	r18, Z
 6cc:	2f 77       	andi	r18, 0x7F	; 127
 6ce:	fc 01       	movw	r30, r24
 6d0:	20 83       	st	Z, r18
	
	if (averaging<8) {
 6d2:	80 91 7a 00 	lds	r24, 0x007A
 6d6:	88 30       	cpi	r24, 0x08	; 8
 6d8:	00 f5       	brcc	.+64     	; 0x71a <ADC_LCD+0xf0>
		averaging++;
 6da:	80 91 7a 00 	lds	r24, 0x007A
 6de:	8f 5f       	subi	r24, 0xFF	; 255
 6e0:	80 93 7a 00 	sts	0x007A, r24
		aver_value+=ADC_values[0];
 6e4:	80 91 6c 00 	lds	r24, 0x006C
 6e8:	28 2f       	mov	r18, r24
 6ea:	30 e0       	ldi	r19, 0x00	; 0
 6ec:	40 e0       	ldi	r20, 0x00	; 0
 6ee:	50 e0       	ldi	r21, 0x00	; 0
 6f0:	80 91 7b 00 	lds	r24, 0x007B
 6f4:	90 91 7c 00 	lds	r25, 0x007C
 6f8:	a0 91 7d 00 	lds	r26, 0x007D
 6fc:	b0 91 7e 00 	lds	r27, 0x007E
 700:	82 0f       	add	r24, r18
 702:	93 1f       	adc	r25, r19
 704:	a4 1f       	adc	r26, r20
 706:	b5 1f       	adc	r27, r21
 708:	80 93 7b 00 	sts	0x007B, r24
 70c:	90 93 7c 00 	sts	0x007C, r25
 710:	a0 93 7d 00 	sts	0x007D, r26
 714:	b0 93 7e 00 	sts	0x007E, r27
 718:	26 c0       	rjmp	.+76     	; 0x766 <ADC_LCD+0x13c>
		}
	else {
		averaging=0;
 71a:	10 92 7a 00 	sts	0x007A, r1
		aver_value>>3;//&&((st_millis()-adc_lcd_timer)>=1)
 71e:	80 91 7b 00 	lds	r24, 0x007B
 722:	90 91 7c 00 	lds	r25, 0x007C
 726:	a0 91 7d 00 	lds	r26, 0x007D
 72a:	b0 91 7e 00 	lds	r27, 0x007E
	//adc_lcd_timer=st_millis();
	//aver_value>>5;
	ptr=&SCR_D[0];
 72e:	83 e8       	ldi	r24, 0x83	; 131
 730:	90 e0       	ldi	r25, 0x00	; 0
 732:	9b 83       	std	Y+3, r25	; 0x03
 734:	8a 83       	std	Y+2, r24	; 0x02
	ptr=(volatile uint8_t *)utoa_fast_div((uint32_t)aver_value, (uint8_t *)ptr);
 736:	80 91 7b 00 	lds	r24, 0x007B
 73a:	90 91 7c 00 	lds	r25, 0x007C
 73e:	a0 91 7d 00 	lds	r26, 0x007D
 742:	b0 91 7e 00 	lds	r27, 0x007E
 746:	2a 81       	ldd	r18, Y+2	; 0x02
 748:	3b 81       	ldd	r19, Y+3	; 0x03
 74a:	a9 01       	movw	r20, r18
 74c:	bc 01       	movw	r22, r24
 74e:	cd 01       	movw	r24, r26
 750:	fd de       	rcall	.-518    	; 0x54c <utoa_fast_div>
 752:	9b 83       	std	Y+3, r25	; 0x03
 754:	8a 83       	std	Y+2, r24	; 0x02
	aver_value=0;
 756:	10 92 7b 00 	sts	0x007B, r1
 75a:	10 92 7c 00 	sts	0x007C, r1
 75e:	10 92 7d 00 	sts	0x007D, r1
 762:	10 92 7e 00 	sts	0x007E, r1
	}
	adc_lcd_timer=st_millis();
 766:	98 d1       	rcall	.+816    	; 0xa98 <st_millis>
 768:	dc 01       	movw	r26, r24
 76a:	cb 01       	movw	r24, r22
 76c:	80 93 79 00 	sts	0x0079, r24
	//aver_value=0;
	//averaging=0;
	PT_END(pt);
 770:	19 82       	std	Y+1, r1	; 0x01
 772:	8c 81       	ldd	r24, Y+4	; 0x04
 774:	9d 81       	ldd	r25, Y+5	; 0x05
 776:	fc 01       	movw	r30, r24
 778:	11 82       	std	Z+1, r1	; 0x01
 77a:	10 82       	st	Z, r1
 77c:	83 e0       	ldi	r24, 0x03	; 3
}
 77e:	0f 90       	pop	r0
 780:	0f 90       	pop	r0
 782:	0f 90       	pop	r0
 784:	0f 90       	pop	r0
 786:	0f 90       	pop	r0
 788:	df 91       	pop	r29
 78a:	cf 91       	pop	r28
 78c:	1f 91       	pop	r17
 78e:	0f 91       	pop	r16
 790:	ff 90       	pop	r15
 792:	ef 90       	pop	r14
 794:	08 95       	ret

00000796 <__vector_6>:
–¢–∞–±—É–ª—è—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π 8-–±–∏—Ç –ê–¶–ü –≤ —Ç—É–ø—É—é —Ç—Ä–µ–±—É–µ—Ç 256 –±–∞–π—Ç —Ñ–ª—ç—à–∞, –≤—Ç–æ—Ä–æ–π –≤–∞—Ä–∏–∞–Ω—Ç - —Ç—É–ø–æ –ø–µ—Ä–µ—Å—á–µ—Ç
(–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞, –ª–∏–±–æ —Å–¥–≤–∏–≥–∏, –ª–∏–±–æ –ø—Ä–∏–¥—É–º—ã–≤–∞—Ç—å —á–Ω–≥–æ)
*/

ISR(TIMER1_COMPA_vect)
{
 796:	1f 92       	push	r1
 798:	0f 92       	push	r0
 79a:	00 90 5f 00 	lds	r0, 0x005F
 79e:	0f 92       	push	r0
 7a0:	11 24       	eor	r1, r1
 7a2:	8f 93       	push	r24
 7a4:	9f 93       	push	r25
 7a6:	ef 93       	push	r30
 7a8:	ff 93       	push	r31
 7aa:	cf 93       	push	r28
 7ac:	df 93       	push	r29
 7ae:	cd b7       	in	r28, 0x3d	; 61
 7b0:	de b7       	in	r29, 0x3e	; 62
	TCNT1H=0; //—Å–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞
 7b2:	8d e4       	ldi	r24, 0x4D	; 77
 7b4:	90 e0       	ldi	r25, 0x00	; 0
 7b6:	fc 01       	movw	r30, r24
 7b8:	10 82       	st	Z, r1
	TCNT1L=0;
 7ba:	8c e4       	ldi	r24, 0x4C	; 76
 7bc:	90 e0       	ldi	r25, 0x00	; 0
 7be:	fc 01       	movw	r30, r24
 7c0:	10 82       	st	Z, r1
}
 7c2:	df 91       	pop	r29
 7c4:	cf 91       	pop	r28
 7c6:	ff 91       	pop	r31
 7c8:	ef 91       	pop	r30
 7ca:	9f 91       	pop	r25
 7cc:	8f 91       	pop	r24
 7ce:	0f 90       	pop	r0
 7d0:	00 92 5f 00 	sts	0x005F, r0
 7d4:	0f 90       	pop	r0
 7d6:	1f 90       	pop	r1
 7d8:	18 95       	reti

000007da <__vector_14>:
ISR(ADC_vect)
{
 7da:	1f 92       	push	r1
 7dc:	0f 92       	push	r0
 7de:	00 90 5f 00 	lds	r0, 0x005F
 7e2:	0f 92       	push	r0
 7e4:	11 24       	eor	r1, r1
 7e6:	2f 93       	push	r18
 7e8:	3f 93       	push	r19
 7ea:	8f 93       	push	r24
 7ec:	9f 93       	push	r25
 7ee:	ef 93       	push	r30
 7f0:	ff 93       	push	r31
 7f2:	cf 93       	push	r28
 7f4:	df 93       	push	r29
 7f6:	cd b7       	in	r28, 0x3d	; 61
 7f8:	de b7       	in	r29, 0x3e	; 62
	ADC_values[ADC_counter]=ADCH;
 7fa:	80 91 70 00 	lds	r24, 0x0070
 7fe:	88 2f       	mov	r24, r24
 800:	90 e0       	ldi	r25, 0x00	; 0
 802:	25 e2       	ldi	r18, 0x25	; 37
 804:	30 e0       	ldi	r19, 0x00	; 0
 806:	f9 01       	movw	r30, r18
 808:	20 81       	ld	r18, Z
 80a:	84 59       	subi	r24, 0x94	; 148
 80c:	9f 4f       	sbci	r25, 0xFF	; 255
 80e:	fc 01       	movw	r30, r24
 810:	20 83       	st	Z, r18
	ADMUX|=0b00001111; //–≤—Å–µ –∫–∞–Ω–∞–ª—ã –ê–¶–ü —Å–∞–∂–∞–µ–º –Ω–∞ –∑–µ–º–ª—é, –ø–µ—Ä–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ–∫–æ–Ω—á–µ–Ω–æ
 812:	87 e2       	ldi	r24, 0x27	; 39
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	27 e2       	ldi	r18, 0x27	; 39
 818:	30 e0       	ldi	r19, 0x00	; 0
 81a:	f9 01       	movw	r30, r18
 81c:	20 81       	ld	r18, Z
 81e:	2f 60       	ori	r18, 0x0F	; 15
 820:	fc 01       	movw	r30, r24
 822:	20 83       	st	Z, r18
	ADC_counter++;
 824:	80 91 70 00 	lds	r24, 0x0070
 828:	8f 5f       	subi	r24, 0xFF	; 255
 82a:	80 93 70 00 	sts	0x0070, r24
	if (ADC_counter<4) 
 82e:	80 91 70 00 	lds	r24, 0x0070
 832:	84 30       	cpi	r24, 0x04	; 4
 834:	68 f4       	brcc	.+26     	; 0x850 <__vector_14+0x76>
	{
		ADMUX=(ADMUX&(~15))|ADC_counter; //–ø–æ–¥–∫–ª—é—á–∞–µ–º –Ω—É–∂–Ω—ã–π –∫–∞–Ω–∞–ª
 836:	87 e2       	ldi	r24, 0x27	; 39
 838:	90 e0       	ldi	r25, 0x00	; 0
 83a:	27 e2       	ldi	r18, 0x27	; 39
 83c:	30 e0       	ldi	r19, 0x00	; 0
 83e:	f9 01       	movw	r30, r18
 840:	20 81       	ld	r18, Z
 842:	20 7f       	andi	r18, 0xF0	; 240
 844:	30 91 70 00 	lds	r19, 0x0070
 848:	23 2b       	or	r18, r19
 84a:	fc 01       	movw	r30, r24
 84c:	20 83       	st	Z, r18
 84e:	0b c0       	rjmp	.+22     	; 0x866 <__vector_14+0x8c>
	}
	else
	{
		ADC_counter=0; //—Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫
 850:	10 92 70 00 	sts	0x0070, r1
		ADMUX=(ADMUX&(~15));//–ø–æ–¥–∫–ª—é—á–∞–µ–º –Ω—É–ª–µ–≤–æ–π –∫–∞–Ω–∞–ª –ê–¶–ü
 854:	87 e2       	ldi	r24, 0x27	; 39
 856:	90 e0       	ldi	r25, 0x00	; 0
 858:	27 e2       	ldi	r18, 0x27	; 39
 85a:	30 e0       	ldi	r19, 0x00	; 0
 85c:	f9 01       	movw	r30, r18
 85e:	20 81       	ld	r18, Z
 860:	20 7f       	andi	r18, 0xF0	; 240
 862:	fc 01       	movw	r30, r24
 864:	20 83       	st	Z, r18
	}
	ADCSRA|=(_BV(6)); //—Ç–∞–∫ —Ä–∞–±–æ–∞—Ç–µ—Ç –≤ —Ä–µ–∂–∏–º–µ —Ñ—Ä–∏  —Ä–∞–Ω–∏–Ω–≥ –º–æ–¥–µ —Ö–µ—Ä–Ω—è —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º –¥–∞–Ω–Ω—ã—Ö —Å –∫–∞–Ω–∞–ª–æ–≤ –≤ –º–∞—Å—Å–∏–≤–µ
 866:	86 e2       	ldi	r24, 0x26	; 38
 868:	90 e0       	ldi	r25, 0x00	; 0
 86a:	26 e2       	ldi	r18, 0x26	; 38
 86c:	30 e0       	ldi	r19, 0x00	; 0
 86e:	f9 01       	movw	r30, r18
 870:	20 81       	ld	r18, Z
 872:	20 64       	ori	r18, 0x40	; 64
 874:	fc 01       	movw	r30, r24
 876:	20 83       	st	Z, r18
}
 878:	df 91       	pop	r29
 87a:	cf 91       	pop	r28
 87c:	ff 91       	pop	r31
 87e:	ef 91       	pop	r30
 880:	9f 91       	pop	r25
 882:	8f 91       	pop	r24
 884:	3f 91       	pop	r19
 886:	2f 91       	pop	r18
 888:	0f 90       	pop	r0
 88a:	00 92 5f 00 	sts	0x005F, r0
 88e:	0f 90       	pop	r0
 890:	1f 90       	pop	r1
 892:	18 95       	reti

00000894 <__vector_12>:
ISR(USART_UDRE_vect)
{
 894:	1f 92       	push	r1
 896:	0f 92       	push	r0
 898:	00 90 5f 00 	lds	r0, 0x005F
 89c:	0f 92       	push	r0
 89e:	11 24       	eor	r1, r1
 8a0:	cf 93       	push	r28
 8a2:	df 93       	push	r29
 8a4:	cd b7       	in	r28, 0x3d	; 61
 8a6:	de b7       	in	r29, 0x3e	; 62
	//UDR=ADC_values[0];
	//UCSRB &=~(1<<UDRIE); //–∑–∞–ø—Ä–µ—â–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ—Ç UART, –ø–µ—Ä–µ–¥–∞—á–∞ —â–∞–∞	
}
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	0f 90       	pop	r0
 8ae:	00 92 5f 00 	sts	0x005F, r0
 8b2:	0f 90       	pop	r0
 8b4:	1f 90       	pop	r1
 8b6:	18 95       	reti

000008b8 <main>:

int main(void)
{
 8b8:	cf 93       	push	r28
 8ba:	df 93       	push	r29
 8bc:	cd b7       	in	r28, 0x3d	; 61
 8be:	de b7       	in	r29, 0x3e	; 62
	//uint8_t noise_level_value=0;
	//initiate ports
	DDRD=255; //all pins on portd are outputs
 8c0:	81 e3       	ldi	r24, 0x31	; 49
 8c2:	90 e0       	ldi	r25, 0x00	; 0
 8c4:	2f ef       	ldi	r18, 0xFF	; 255
 8c6:	fc 01       	movw	r30, r24
 8c8:	20 83       	st	Z, r18
	DDRB=0b11000111;
 8ca:	87 e3       	ldi	r24, 0x37	; 55
 8cc:	90 e0       	ldi	r25, 0x00	; 0
 8ce:	27 ec       	ldi	r18, 0xC7	; 199
 8d0:	fc 01       	movw	r30, r24
 8d2:	20 83       	st	Z, r18
	DDRC=0b11110000;//ADC pins inputs
 8d4:	84 e3       	ldi	r24, 0x34	; 52
 8d6:	90 e0       	ldi	r25, 0x00	; 0
 8d8:	20 ef       	ldi	r18, 0xF0	; 240
 8da:	fc 01       	movw	r30, r24
 8dc:	20 83       	st	Z, r18
	//DDRA='0b11010000';
	PORTD=0;
 8de:	82 e3       	ldi	r24, 0x32	; 50
 8e0:	90 e0       	ldi	r25, 0x00	; 0
 8e2:	fc 01       	movw	r30, r24
 8e4:	10 82       	st	Z, r1
	PORTB=0b00111000;
 8e6:	88 e3       	ldi	r24, 0x38	; 56
 8e8:	90 e0       	ldi	r25, 0x00	; 0
 8ea:	28 e3       	ldi	r18, 0x38	; 56
 8ec:	fc 01       	movw	r30, r24
 8ee:	20 83       	st	Z, r18
	PORTC=0;
 8f0:	85 e3       	ldi	r24, 0x35	; 53
 8f2:	90 e0       	ldi	r25, 0x00	; 0
 8f4:	fc 01       	movw	r30, r24
 8f6:	10 82       	st	Z, r1
	   PORTB PIN1 - out PWM TEC, PIN2- input ERROR_IN (RED_BUTTON), PIN3,PIN4 - inputs encoder, PIN5 - input encoder button  
	   PortA - Pin0 - Cur_Mon, Pin1 - V_mon, Pin2 - NTC1, PIN3 - NTC2, PIN4 - LD_PWM_OUT, PIN5 - DS raiator sensor

*/
	// Set prescaler to 64
	TCCR0 |= (_BV(CS01) | _BV(CS00));
 8f8:	83 e5       	ldi	r24, 0x53	; 83
 8fa:	90 e0       	ldi	r25, 0x00	; 0
 8fc:	23 e5       	ldi	r18, 0x53	; 83
 8fe:	30 e0       	ldi	r19, 0x00	; 0
 900:	f9 01       	movw	r30, r18
 902:	20 81       	ld	r18, Z
 904:	23 60       	ori	r18, 0x03	; 3
 906:	fc 01       	movw	r30, r24
 908:	20 83       	st	Z, r18
	// Enable interrupt
	TIMSK |= _BV(TOIE0) | _BV(OCIE1A);
 90a:	89 e5       	ldi	r24, 0x59	; 89
 90c:	90 e0       	ldi	r25, 0x00	; 0
 90e:	29 e5       	ldi	r18, 0x59	; 89
 910:	30 e0       	ldi	r19, 0x00	; 0
 912:	f9 01       	movw	r30, r18
 914:	20 81       	ld	r18, Z
 916:	21 61       	ori	r18, 0x11	; 17
 918:	fc 01       	movw	r30, r24
 91a:	20 83       	st	Z, r18
	// Set default value
	TCNT0 = ST_CTC_HANDMADE; //1ms tiks on 8mhz CPU clock
 91c:	82 e5       	ldi	r24, 0x52	; 82
 91e:	90 e0       	ldi	r25, 0x00	; 0
 920:	22 e8       	ldi	r18, 0x82	; 130
 922:	fc 01       	movw	r30, r24
 924:	20 83       	st	Z, r18
	
	//set timer 1 for PWM
	//TCCR1A=0b01000000; //–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ oc1A –ø–æ —Å–æ–±—ã—Ç–∏–µ –Ω–∞ —Ç–∞–π–º–µ—Ä–µ, oc1b –ª—å–∫–ª—é—á–µ–Ω
	//TCCR1B=0b00000001; //clocked from CLK=8MHZ
	OCR1AH=0;
 926:	8b e4       	ldi	r24, 0x4B	; 75
 928:	90 e0       	ldi	r25, 0x00	; 0
 92a:	fc 01       	movw	r30, r24
 92c:	10 82       	st	Z, r1
	OCR1AL=255;
 92e:	8a e4       	ldi	r24, 0x4A	; 74
 930:	90 e0       	ldi	r25, 0x00	; 0
 932:	2f ef       	ldi	r18, 0xFF	; 255
 934:	fc 01       	movw	r30, r24
 936:	20 83       	st	Z, r18
	//–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ê–¶–ü
	ADMUX=0b11100000; //–æ–ø–æ—Ä–Ω–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ –æ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –ò–û–ù (2,56V), –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é (—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ ADCH), –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å –ê–¶–ü –∫ –≤—Ö–æ–¥—É ADC0;
 938:	87 e2       	ldi	r24, 0x27	; 39
 93a:	90 e0       	ldi	r25, 0x00	; 0
 93c:	20 ee       	ldi	r18, 0xE0	; 224
 93e:	fc 01       	movw	r30, r24
 940:	20 83       	st	Z, r18
	ADCSRA=0b00001111; //—Ä–µ–∑—Ä–µ—à–∏—Ç—å –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –æ—Ç –ê–¶–ü, –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–ª–∏—Ç–µ–ª—å —á–∞—Å—Ç–æ—Ç—ã 128
 942:	86 e2       	ldi	r24, 0x26	; 38
 944:	90 e0       	ldi	r25, 0x00	; 0
 946:	2f e0       	ldi	r18, 0x0F	; 15
 948:	fc 01       	movw	r30, r24
 94a:	20 83       	st	Z, r18
	MCUCR|=0b00010000;//—É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ADC_noise canceling mode
 94c:	85 e5       	ldi	r24, 0x55	; 85
 94e:	90 e0       	ldi	r25, 0x00	; 0
 950:	25 e5       	ldi	r18, 0x55	; 85
 952:	30 e0       	ldi	r19, 0x00	; 0
 954:	f9 01       	movw	r30, r18
 956:	20 81       	ld	r18, Z
 958:	20 61       	ori	r18, 0x10	; 16
 95a:	fc 01       	movw	r30, r24
 95c:	20 83       	st	Z, r18
	*/
	
	//noise_level_value=ADC_init();
	//pid_Init(P_FACTOR,I_FACTOR,D_FACTOR, pid_reg_st);
		
	PT_INIT(&SegDyn_pt);
 95e:	10 92 72 00 	sts	0x0072, r1
 962:	10 92 71 00 	sts	0x0071, r1
	PT_INIT(&EncoderButton_pt);
 966:	10 92 76 00 	sts	0x0076, r1
 96a:	10 92 75 00 	sts	0x0075, r1
	PT_INIT(&EncoderScan_pt);
 96e:	10 92 74 00 	sts	0x0074, r1
 972:	10 92 73 00 	sts	0x0073, r1
	PT_INIT(&ADC_LCD_pt);
 976:	10 92 78 00 	sts	0x0078, r1
 97a:	10 92 77 00 	sts	0x0077, r1
	//PT_INIT(&CurrentCalc_pt);
	//PT_INIT(&PID_LD_CURR_pt);
	
	wdt_reset(); //—Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ–±–∞–∫—É –Ω–∞ –≤—Å—è–∫–∏–π –ø–æ–∂–∞—Ä–Ω—ã–π
 97e:	a8 95       	wdr
				"out __SREG__,__tmp_reg__" "\n\t"
				"out %0, %2" "\n \t"
				: /* no outputs */
				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 980:	87 e0       	ldi	r24, 0x07	; 7
 982:	87 70       	andi	r24, 0x07	; 7
 984:	88 60       	ori	r24, 0x08	; 8
 986:	98 2f       	mov	r25, r24
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
 988:	88 e1       	ldi	r24, 0x18	; 24
 98a:	0f b6       	in	r0, 0x3f	; 63
 98c:	f8 94       	cli
 98e:	a8 95       	wdr
 990:	81 bd       	out	0x21, r24	; 33
 992:	0f be       	out	0x3f, r0	; 63
 994:	91 bd       	out	0x21, r25	; 33
	wdt_enable(WDTO_2S); //–∑–∞–ø—É—Å–∫–∞–µ–º —Å–æ–±–∞–∫—É —Å –ø–µ—Ä–∏–¥–æ–º 2—Å
	
	sei();
 996:	78 94       	sei
	//ADCSRA|=(_BV(7))|(_BV(6)); //–∑–∞–ø—É—Å–∫–∞–µ–º –ê–¶–ü –≤ –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
	//ADCSRA|=(_BV(7));
	//UDR = ADC_values[0];		// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–π—Ç
	//UCSRB|=(1<<UDRIE);	// –†–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ UDRE
	SCR_D[0]=2;
 998:	82 e0       	ldi	r24, 0x02	; 2
 99a:	80 93 83 00 	sts	0x0083, r24
	SCR_D[1]=8;
 99e:	88 e0       	ldi	r24, 0x08	; 8
 9a0:	80 93 84 00 	sts	0x0084, r24
	SCR_D[2]=6;
 9a4:	86 e0       	ldi	r24, 0x06	; 6
 9a6:	80 93 85 00 	sts	0x0085, r24

    while(1)
    {
		//EncoderScan(&EncoderScan_pt);
		//CurrentCalc(&CurrentCalc_pt);
		SegDyn(&SegDyn_pt);
 9aa:	81 e7       	ldi	r24, 0x71	; 113
 9ac:	90 e0       	ldi	r25, 0x00	; 0
 9ae:	6c db       	rcall	.-2344   	; 0x88 <SegDyn>
		EncoderButton(&EncoderButton_pt);
 9b0:	85 e7       	ldi	r24, 0x75	; 117
 9b2:	90 e0       	ldi	r25, 0x00	; 0
 9b4:	3a dc       	rcall	.-1932   	; 0x22a <EncoderButton>
		ADC_LCD(&ADC_LCD_pt);
 9b6:	87 e7       	ldi	r24, 0x77	; 119
 9b8:	90 e0       	ldi	r25, 0x00	; 0
 9ba:	37 de       	rcall	.-914    	; 0x62a <ADC_LCD>
		//PID_PWM_LD_CURR(&PID_LD_CURR_pt);
	
		
		if (ButtonState==BUTTON_ON) PORTB|=1; //–≤–∫–ª—é—á–∏—Ç—å dot
 9bc:	80 91 65 00 	lds	r24, 0x0065
 9c0:	81 30       	cpi	r24, 0x01	; 1
 9c2:	51 f4       	brne	.+20     	; 0x9d8 <main+0x120>
 9c4:	88 e3       	ldi	r24, 0x38	; 56
 9c6:	90 e0       	ldi	r25, 0x00	; 0
 9c8:	28 e3       	ldi	r18, 0x38	; 56
 9ca:	30 e0       	ldi	r19, 0x00	; 0
 9cc:	f9 01       	movw	r30, r18
 9ce:	20 81       	ld	r18, Z
 9d0:	21 60       	ori	r18, 0x01	; 1
 9d2:	fc 01       	movw	r30, r24
 9d4:	20 83       	st	Z, r18
 9d6:	09 c0       	rjmp	.+18     	; 0x9ea <main+0x132>
		else PORTB&=~1;
 9d8:	88 e3       	ldi	r24, 0x38	; 56
 9da:	90 e0       	ldi	r25, 0x00	; 0
 9dc:	28 e3       	ldi	r18, 0x38	; 56
 9de:	30 e0       	ldi	r19, 0x00	; 0
 9e0:	f9 01       	movw	r30, r18
 9e2:	20 81       	ld	r18, Z
 9e4:	2e 7f       	andi	r18, 0xFE	; 254
 9e6:	fc 01       	movw	r30, r24
 9e8:	20 83       	st	Z, r18
		wdt_reset(); //–ø–µ—Ä–µ–æ–¥–∏—á–µ—Å–∫–∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ–±–∞–∫—É —á—Ç–æ–±—ã –Ω–µ —É–ª–µ—Ç–µ—Ç–µ—Ç—å –≤ —Ä–µ—Å–µ—Ç
 9ea:	a8 95       	wdr
	 }
 9ec:	de cf       	rjmp	.-68     	; 0x9aa <main+0xf2>

000009ee <__iCliRetVal>:
    sei();
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
 9ee:	cf 93       	push	r28
 9f0:	df 93       	push	r29
 9f2:	cd b7       	in	r28, 0x3d	; 61
 9f4:	de b7       	in	r29, 0x3e	; 62
    cli();
 9f6:	f8 94       	cli
    return 1;
 9f8:	81 e0       	ldi	r24, 0x01	; 1
}
 9fa:	df 91       	pop	r29
 9fc:	cf 91       	pop	r28
 9fe:	08 95       	ret

00000a00 <__iRestore>:
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
 a00:	cf 93       	push	r28
 a02:	df 93       	push	r29
 a04:	00 d0       	rcall	.+0      	; 0xa06 <__iRestore+0x6>
 a06:	cd b7       	in	r28, 0x3d	; 61
 a08:	de b7       	in	r29, 0x3e	; 62
 a0a:	9a 83       	std	Y+2, r25	; 0x02
 a0c:	89 83       	std	Y+1, r24	; 0x01
    SREG = *__s;
 a0e:	8f e5       	ldi	r24, 0x5F	; 95
 a10:	90 e0       	ldi	r25, 0x00	; 0
 a12:	29 81       	ldd	r18, Y+1	; 0x01
 a14:	3a 81       	ldd	r19, Y+2	; 0x02
 a16:	f9 01       	movw	r30, r18
 a18:	20 81       	ld	r18, Z
 a1a:	fc 01       	movw	r30, r24
 a1c:	20 83       	st	Z, r18
    __asm__ volatile ("" ::: "memory");
}
 a1e:	0f 90       	pop	r0
 a20:	0f 90       	pop	r0
 a22:	df 91       	pop	r29
 a24:	cf 91       	pop	r28
 a26:	08 95       	ret

00000a28 <__vector_9>:
#include <util/atomic.h>

volatile static uint32_t st_timer0_millis;

ISR(TIMER0_OVF_vect)
{
 a28:	1f 92       	push	r1
 a2a:	0f 92       	push	r0
 a2c:	00 90 5f 00 	lds	r0, 0x005F
 a30:	0f 92       	push	r0
 a32:	11 24       	eor	r1, r1
 a34:	2f 93       	push	r18
 a36:	8f 93       	push	r24
 a38:	9f 93       	push	r25
 a3a:	af 93       	push	r26
 a3c:	bf 93       	push	r27
 a3e:	ef 93       	push	r30
 a40:	ff 93       	push	r31
 a42:	cf 93       	push	r28
 a44:	df 93       	push	r29
 a46:	cd b7       	in	r28, 0x3d	; 61
 a48:	de b7       	in	r29, 0x3e	; 62
	st_timer0_millis++;
 a4a:	80 91 7f 00 	lds	r24, 0x007F
 a4e:	90 91 80 00 	lds	r25, 0x0080
 a52:	a0 91 81 00 	lds	r26, 0x0081
 a56:	b0 91 82 00 	lds	r27, 0x0082
 a5a:	01 96       	adiw	r24, 0x01	; 1
 a5c:	a1 1d       	adc	r26, r1
 a5e:	b1 1d       	adc	r27, r1
 a60:	80 93 7f 00 	sts	0x007F, r24
 a64:	90 93 80 00 	sts	0x0080, r25
 a68:	a0 93 81 00 	sts	0x0081, r26
 a6c:	b0 93 82 00 	sts	0x0082, r27
	TCNT0 = ST_CTC_HANDMADE;
 a70:	82 e5       	ldi	r24, 0x52	; 82
 a72:	90 e0       	ldi	r25, 0x00	; 0
 a74:	22 e8       	ldi	r18, 0x82	; 130
 a76:	fc 01       	movw	r30, r24
 a78:	20 83       	st	Z, r18
}
 a7a:	df 91       	pop	r29
 a7c:	cf 91       	pop	r28
 a7e:	ff 91       	pop	r31
 a80:	ef 91       	pop	r30
 a82:	bf 91       	pop	r27
 a84:	af 91       	pop	r26
 a86:	9f 91       	pop	r25
 a88:	8f 91       	pop	r24
 a8a:	2f 91       	pop	r18
 a8c:	0f 90       	pop	r0
 a8e:	00 92 5f 00 	sts	0x005F, r0
 a92:	0f 90       	pop	r0
 a94:	1f 90       	pop	r1
 a96:	18 95       	reti

00000a98 <st_millis>:

uint32_t st_millis(void)
{
 a98:	cf 93       	push	r28
 a9a:	df 93       	push	r29
 a9c:	00 d0       	rcall	.+0      	; 0xa9e <st_millis+0x6>
 a9e:	00 d0       	rcall	.+0      	; 0xaa0 <st_millis+0x8>
 aa0:	00 d0       	rcall	.+0      	; 0xaa2 <st_millis+0xa>
 aa2:	cd b7       	in	r28, 0x3d	; 61
 aa4:	de b7       	in	r29, 0x3e	; 62
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 aa6:	8f e5       	ldi	r24, 0x5F	; 95
 aa8:	90 e0       	ldi	r25, 0x00	; 0
 aaa:	fc 01       	movw	r30, r24
 aac:	80 81       	ld	r24, Z
 aae:	8e 83       	std	Y+6, r24	; 0x06
 ab0:	9e df       	rcall	.-196    	; 0x9ee <__iCliRetVal>
 ab2:	8d 83       	std	Y+5, r24	; 0x05
 ab4:	0d c0       	rjmp	.+26     	; 0xad0 <st_millis+0x38>
	{
		m = st_timer0_millis;
 ab6:	80 91 7f 00 	lds	r24, 0x007F
 aba:	90 91 80 00 	lds	r25, 0x0080
 abe:	a0 91 81 00 	lds	r26, 0x0081
 ac2:	b0 91 82 00 	lds	r27, 0x0082
 ac6:	89 83       	std	Y+1, r24	; 0x01
 ac8:	9a 83       	std	Y+2, r25	; 0x02
 aca:	ab 83       	std	Y+3, r26	; 0x03
 acc:	bc 83       	std	Y+4, r27	; 0x04

uint32_t st_millis(void)
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 ace:	1d 82       	std	Y+5, r1	; 0x05
 ad0:	8d 81       	ldd	r24, Y+5	; 0x05
 ad2:	88 23       	and	r24, r24
 ad4:	81 f7       	brne	.-32     	; 0xab6 <st_millis+0x1e>
 ad6:	ce 01       	movw	r24, r28
 ad8:	06 96       	adiw	r24, 0x06	; 6
 ada:	92 df       	rcall	.-220    	; 0xa00 <__iRestore>
	{
		m = st_timer0_millis;
	}

	return m;
 adc:	89 81       	ldd	r24, Y+1	; 0x01
 ade:	9a 81       	ldd	r25, Y+2	; 0x02
 ae0:	ab 81       	ldd	r26, Y+3	; 0x03
 ae2:	bc 81       	ldd	r27, Y+4	; 0x04
}
 ae4:	bc 01       	movw	r22, r24
 ae6:	cd 01       	movw	r24, r26
 ae8:	26 96       	adiw	r28, 0x06	; 6
 aea:	0f b6       	in	r0, 0x3f	; 63
 aec:	f8 94       	cli
 aee:	de bf       	out	0x3e, r29	; 62
 af0:	0f be       	out	0x3f, r0	; 63
 af2:	cd bf       	out	0x3d, r28	; 61
 af4:	df 91       	pop	r29
 af6:	cf 91       	pop	r28
 af8:	08 95       	ret

00000afa <_exit>:
 afa:	f8 94       	cli

00000afc <__stop_program>:
 afc:	ff cf       	rjmp	.-2      	; 0xafc <__stop_program>
